Time framework
==============

Time and performance units
--------------------------

Time inside of the emulation is referred to as *virtual time* (as opposed to the *host time* or *real time*) and is expressed in *virtual seconds*.
Currently the resolution of *virtual time*, i.e., the minimum expressable time quant, is 10^-6 *virtual second* or 1 *virtual microsecond*.
Performance of CPU is expressed in *MIPS* units (*millions instrunctions per second*) and is an integer value.
This means that minimum time quant allows precisely to execute a single instruction on a CPU with performance of 1 *MIPS*.

.. note::

    For CPU with performance higher than 1 *MIPS* it is possible to execute instruction-by-instruction using special *stepping* mode.

Time sources and sinks
----------------------

Objects controlling flow of *virtual time* are called *time sources*.
By default there is one *time source*, called *master time source*, assosiated with the emulation.
Currently there is no API to create other *master time sources*, but the framework itself is capable of handling multiple *time domains* (with each *master time source* being a root of the domain).

Objects that are aware of the time passing are called *time sinks*.
Each *sink* is connected to exactly one *source* (at the time, although it can roam between *sources*) and awaits information about how much *virtual time* has passed so far.

There are object that plays both roles: *sink* and *source* - they are called *slave time sources*.
The reason for having a *slave time source* is explained in the following section.

Synchronization
---------------

Virtual time flows in a form of *quants* generated by *master time sources* and granted to *sinks*.
The value of *quant* is expressed in *virtual seconds* (or fraction of it) and is configurable by the user.
Once a *quant* is granted to *sinks*, *source* waits for them to finish execution.
After all slaves reports back there is time for a *synchronization phase*.
As it is guaranteed that no nodes work during this phase, it is safe to process all intra-node communication during it.
Only when the *synchronization phase* is finised, new *quant* can be granted to all *sinks*.

It is possible to introduce *slave time sources* in the *domain* that divides quantum into smaller fragments and allows for tighter synchronization of selected nodes.

Time domain
-----------

Configuration of *time sources* and *time slaves* connected together is called a *time domain*.
All members of a *time domain* observe flow of the same *virtual time* and are synchronized together.
In case of having multiple *time domains* the time values are not comparable between them - in other words, there is no synchronization across the *time domains*.

There is one *time domain* by default in the emulation.
*Master time source* is associated with the emulation itself, every machine provides it's own *slave time source* that drives CPU(s) being a *sink*.

Configuration and monitoring
----------------------------

There are several properties provided by a *time source* that can be used to tune a *virtual time* flow:

*Quantum*
    The amount of *virtual time* between two *synchronization phases*.
    It is guraranteed that the difference of *virtual time* perceived of two *slaves* is never higher than a *quantum* of it's closest common *source*.

    Value of *quantum* can be changed between *synchronization phases*, but the new value won't be used until the nearest grant.

    *Slave time source* can have different *quantum* than it's *master time source*.
    In case the slave's quantum is smaller than master's, slave will split the quantum into smaller pieces and report back to master only when all the pieces are used up.
    In case the slave's quantum is bigger than master's, slave will report immediately (doing no job) and accumulate the granted interval until it reaches the required quantum.

    It is illegal to set *quantum* to *zero* as it would not allow the *virtual time* to pass at all.

*Performance*
    Floating-point value describing the ratio of *virtual* to *real* time flow.
    Value of *1.0* means that the *virtual time* should in average pass in the same pace as a *real* one - user feels like using a real hardware; software that sleeps for a 1 second should sleep for a 1 second.
    Value higher than *1.0* means that the *virtual time* should pass faster than the *real* one - it can be used to speed up long emulations (e.g., test what happens in the emulated system after 24 hours of uptime).
    Value lower than *1.0* means that the *virtual time* should pass slower than the *real* one - it can be used to slow down emulation when a lot of events is happening in a short period.

    The performance of the host machine puts a natural limit on an effective values of this parameter (see ``CurrentLoad``).
    It is possible to temporarily overwrite this setting by using ``AdanveImmediately`` property.

*AdvanceImmediately*
    Boolean value that can be used to overwrite the current value of ``Performance`` and force the emulation to execute as fast as possible.


There are also some read-only properties that can be used to monitor the current state of the *source*:

*CurrentLoad*
    Floating-point value indicating the stress the emulation puts on a host CPU.

    Value of *1.0* (the maximal possible) means that the host uses all it's CPU resources to run current emulation and it is not possible to execute it faster.
    In other words, increasing *Performance* will not give any effect.

    Value of *0.5* means that the host is loaded only in 50% so it is possible to speed the emulation up by the factor of 2.

    This value is calculated as an avarage of *10* samples.

*CummulativeLoad*
    The same as ``Load`` but calculated as an average over all samples since the beginning of the emulation.

*ElapsedVirtualTime*
    The amount of *virtual time* that passed since the *source* has been started.

*NearestSyncPoint*
    The time stamp of the nearest *synchronization phase*.

*NumberOfSyncPoints*
    The number of *synchronization phases* executed so far.


CPU pausing vs. halting
-----------------------

When any of the members of *time domain* pauses it's execution it will effectively block *virtual time* from passing.
As a result all other members will execute to the nearest *synchronization phase* and wait for paused member to continue.

Sometimes it is convinient to have a member in the *domain* that is disabled, but do not block others - e.g., a CPU in multi-CPU architectures that is not clocked.
*CPU* provides ``IsHalted`` property that allows to achieve this goal.
